# Context Graph Architecture

The Context Graph (Single Session Graph) visualization was refactored to support complex branching logic, rather than a strictly linear sequence for agent workflows. This document details the architectural shifts in both the backend data aggregation and frontend visualization.

## Overview

Previously, the `get_context_graph` backend endpoint emitted a flat, linear array of steps strictly ordered by timestamp. The frontend `ContextGraphViewer` simply linked each node `N_i` to `N_i+1`. This created overly long, confusing graphs when tools generated complex outputs or when the agent performed multiple intermediate reasoning steps.

The new architecture clusters operations logically around trace boundaries (representing "Thoughts" or distinct turns), enabling the graph to use tree-like branching and providing a much more readable semantic structure.

## Conceptual Model: The ReAct Loop

The evolution of the context graph is directly tied to the theoretical operation of ReAct (Reason + Act) agents.

### The Linear Reality (Telemetry)
In strictly chronological telemetry pipelines (like OpenTelemetry traces), all spans generated by an agent's orchestration logic run in a linear timeline from start to finish. A span for reasoning is followed immediately in time by a span executing a tool, which is followed by the parser evaluating the tool's result, before the agent loops to think again. Plotting this linearly works well for calculating system latency, but poorly captures the cognitive structure and state of the agent.

### The Branching Hierarchy (Cognition)
The cognitive state of an agent is fundamentally cyclical and hierarchical:
1. **The Backbone (Thought Trajectory):** The agent enters an evaluation loop aimed toward a goal (`INCIDENT`). It forms a `THOUGHT` (such as analyzing telemetry and user context). Each loop iteration represents a core sequence in its trajectory.
2. **The Excursions (Actions/Observations):** When a thought leads to a specific strategy requiring external context, the agent "branches out" to perform a `TOOL_CALL`.
3. **The Returns (State Updates):** The result of that tool call is an `OBSERVATION` that feeds back into the agent's context window. It doesn't proceed to the next linear step independently; it essentially returns to the agent to inform the *next* logical thought in the backbone sequence.

By pulling `TOOL_CALL` and `OBSERVATION` pairs out into structural branches off a sequential Thought backbone, we emulate how the agent dynamically loops and builds context. This maps a purely chronological execution history into a logical cognitive tree.

## Backend Changes (`agent_graph.py`)

The `get_context_graph` endpoint now acts as a semantic aggregator:

1.  **Trace-based Sub-graphs (The "Backbone"):**
    Instead of stringing all nodes end-to-end, the backend now groups BigQuery spans (`agent_spans_raw`) by `trace_id`.
    Each unique `trace_id` generates a central `THOUGHT` node on the main path.
    The backbone of the graph is sequentially linked: `INCIDENT` -> `THOUGHT-1` -> `THOUGHT-n` -> `ACTION`.

2.  **Branching Tool Calls:**
    Spans representing tools (`node_type == 'Tool'`) are identified within their respective trace groups.
    For each tool, the backend generates a `TOOL_CALL` node branching off its parent `THOUGHT` node, and an `OBSERVATION` node returning from the `TOOL_CALL`.
    ```mermaid
    graph TD
      T[THOUGHT: Analyze DB] --> TC[TOOL_CALL: search_logs]
      TC --> O[OBSERVATION: Result from search_logs]
    ```

3.  **Synthesized Nodes:**
    The backend artificially synthesizes robust bounding nodes for clarity. An `INCIDENT` node acts as the entry point anchoring the investigation, and an `ACTION` node concludes the graph representing the final mitigation or recommendation output.

## Frontend Changes (`agent_ops_ui/src/components`)

To support non-linear, branching layouts gracefully, the frontend was completely decoupled from its previous basic `ReactFlow` implementation.

1.  **Reusing `TopologyGraph` Ecosystem:**
    `ContextGraphViewer.tsx` now uses `<TopologyGraph />` as its rendering engine.
    This injects the complex `dagre`-based layouting system (supporting Horizontal, Vertical, and Clustered algorithms) directly into the single-session context viewer.
    The single-session view immediately gained the Minimap, interactive expanding/collapsing of subtrees, and the advanced zooming/fitting controls natively built into `TopologyGraph`.

2.  **`customNodeTypes` Injection:**
    To allow `TopologyGraph` to render single-session nodes (THOUGHT, TOOL_CALL, OBSERVATION) without modifying its core schema, `TopologyGraph` was enhanced to accept a runtime `customNodeTypes` mapping. `ContextGraphViewer` provides its `CustomNodes.tsx` implementations via this prop.

3.  **Dynamic Handle Positioning:**
    For branching trees to render cleanly in different layouts (e.g. Left-to-Right vs Top-to-Bottom), `CustomNodes.tsx` (the React components for Thoughts, Tools, etc.) were updated. They now consume the `_layoutMode` property injected by `TopologyGraph` to strategically place their edge Handles (e.g., using `Top`/`Bottom` in vertical layout and `Left`/`Right` in horizontal layout).

4.  **Preserved Playback State:**
    The signature feature of `ContextGraphViewer`—replaying the agent's actions over time—was successfully preserved and injected as generic `children` (a React custom Panel) into the underlying `ReactFlow` context held by `TopologyGraph`.

## Summary
By formalizing the trace hierarchy in the backend API and abstracting the powerful `dagre` layout engine on the frontend, the Context Graph now correctly models the agent's thought-action-observation structure exactly as an LLM orchestration loop actually operates.

## Session Trajectory Data Sourcing

While the `get_context_graph` endpoint provides the topological *structure* of interactions, the `get_session_trajectory` endpoint provides the *details* (Prompts, Completions, Tool IO, Logs) rendered in the `SessionLogsView`.

To ensure high data reliability and avoid issues with missing or unparsed JSON columns in BigQuery's `_AllSpans`, the Trajectory API was refactored:
1. **Direct Cloud Trace API:** When a session is requested, the backend determines the active `trace_id`s from BigQuery, but then directly queries the Google Cloud Trace API (`_fetch_trace_sync`) to extract the exact `gen_ai.*` and `tool.*` attributes.
2. **Direct Cloud Logging API:** Similarly, error logs correlated with the agent's spans are fetched directly from the Google Cloud Logging API (`_list_log_entries_sync`) via the trace filters, rather than doing complex BigQuery JSON parsing.

This hybrid approach leverages BigQuery for fast, broad timeline discovery and direct APIs for reliable, deep payload extraction.
