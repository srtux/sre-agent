"""Adapter to expose Runner as an LlmAgent for AdkApp compatibility."""

import logging
from collections.abc import AsyncGenerator

from google.adk.agents import LlmAgent
from google.adk.agents.invocation_context import InvocationContext
from google.adk.events import Event

from sre_agent.auth import SESSION_STATE_PROJECT_ID_KEY
from sre_agent.core.prompt_composer import DomainContext
from sre_agent.core.runner import Runner
from sre_agent.models.investigation import InvestigationState

logger = logging.getLogger(__name__)


class RunnerAgentAdapter(LlmAgent):
    """Adapts a Runner instance to the LlmAgent interface.

    This allows the Runner to be used with google.adk.reasoning_engines.AdkApp
    typically used for Vertex AI deployment.
    """

    def __init__(self, runner: Runner, name: str = "RunnerAgent"):
        """Initialize the adapter.

        Args:
            runner: The configured Runner instance.
            name: Name of the agent.
        """
        super().__init__(name=name)
        object.__setattr__(self, "_runner", runner)

    @property
    def runner(self) -> Runner:
        """Get the underlying runner."""
        return self._runner  # type: ignore[no-any-return,attr-defined]

    async def run_async(  # type: ignore[misc]
        self, context: InvocationContext
    ) -> AsyncGenerator[Event, None]:
        """Execute the runner using the ADK invocation context.

        Args:
            context: ADK InvocationContext containing session and user data.

        Yields:
            Events generated by the Runner.
        """
        session = context.session
        if not session:
            logger.error("No session provided in validation context")
            return

        # Extract user info
        # AdkApp typically populates context.user_content
        user_message = ""
        if context.user_content and context.user_content.parts:
            # Assuming first part is text
            part = context.user_content.parts[0]
            if hasattr(part, "text"):
                user_message = part.text or ""

        user_id = getattr(session, "user_id", "default")

        from opentelemetry import context as otel_context
        from opentelemetry import trace
        from opentelemetry.trace import NonRecordingSpan, SpanContext, TraceFlags

        from sre_agent.auth import SESSION_STATE_TRACE_ID_KEY, set_trace_id

        # PROPAGATION: Set Trace ID from Session State for log correlation
        remote_trace_id = session.state.get(SESSION_STATE_TRACE_ID_KEY)
        token = None
        if remote_trace_id:
            set_trace_id(remote_trace_id)
            try:
                # Link local operations to the global trace!
                # This ensures any spans created here are children of the frontend request.
                # Use a deterministic span_id to represent the "Agent Entry" if we don't have the parent's.
                # OTel spec requires span_id to be non-zero.
                span_id = int(
                    remote_trace_id[:16], 16
                )  # Use first 16 chars as a pseudo-parent ID
                span_context = SpanContext(
                    trace_id=int(remote_trace_id, 16),
                    span_id=span_id,
                    is_remote=True,
                    trace_flags=TraceFlags(TraceFlags.SAMPLED),
                )
                parent_ctx = trace.set_span_in_context(NonRecordingSpan(span_context))
                token = otel_context.attach(parent_ctx)
                logger.debug(
                    f"üìç Attached OTel context with Trace ID: {remote_trace_id}, Parent Span: {span_id:016x}"
                )
            except Exception as e:
                logger.warning(f"Failed to attach OTel context: {e}")

        # Extract Project ID from Session State
        # The proxy ensures this is set in session state before calling Agent Engine
        project_id = session.state.get(SESSION_STATE_PROJECT_ID_KEY)

        logger.info(
            f"üöÄ RunnerAdapter starting turn: user={user_id}, project={project_id}, session={session.id}"
        )

        try:
            # Reconstruct DomainContext from Session State
            # Investigation State should be in session state
            inv_state_dict = session.state.get("investigation_state", {})
            inv_state = (
                InvestigationState.from_dict(inv_state_dict) if inv_state_dict else None
            )

            domain_ctx = DomainContext(
                project_id=project_id,
                investigation_phase=inv_state.phase.value if inv_state else None,
            )

            async for event in self.runner.run_turn(
                session=session,
                user_message=user_message,
                user_id=user_id,
                project_id=project_id,
                domain_context=domain_ctx,
            ):
                yield event
        except Exception as e:
            logger.error(f"üî• RunnerAdapter failed: {e}", exc_info=True)
            # CRITICAL: Yield an error event so the client gets valid ADK protocol response
            # instead of a raw traceback/malformed JSON chunk.
            try:
                yield self.runner._create_error_event(str(e))
            except Exception:
                pass
            # Re-raise to allow AdkApp to handle/return error
            raise e
        finally:
            if token:
                otel_context.detach(token)
