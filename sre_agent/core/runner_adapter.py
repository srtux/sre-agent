"""Adapter to expose Runner as an LlmAgent for AdkApp compatibility."""

import logging
from collections.abc import AsyncGenerator

from google.adk.agents import LlmAgent
from google.adk.agents.invocation_context import InvocationContext
from google.adk.events import Event

from sre_agent.auth import SESSION_STATE_PROJECT_ID_KEY
from sre_agent.core.prompt_composer import DomainContext
from sre_agent.core.runner import Runner
from sre_agent.models.investigation import InvestigationState

logger = logging.getLogger(__name__)


class RunnerAgentAdapter(LlmAgent):
    """Adapts a Runner instance to the LlmAgent interface.

    This allows the Runner to be used with google.adk.reasoning_engines.AdkApp
    typically used for Vertex AI deployment.
    """

    def __init__(self, runner: Runner, name: str = "RunnerAgent"):
        """Initialize the adapter.

        Args:
            runner: The configured Runner instance.
            name: Name of the agent.
        """
        super().__init__(name=name)
        object.__setattr__(self, "_runner", runner)

    @property
    def runner(self) -> Runner:
        """Get the underlying runner."""
        return self._runner  # type: ignore[no-any-return,attr-defined]

    async def run_async(  # type: ignore[misc]
        self, context: InvocationContext
    ) -> AsyncGenerator[Event, None]:
        """Execute the runner using the ADK invocation context.

        Args:
            context: ADK InvocationContext containing session and user data.

        Yields:
            Events generated by the Runner.
        """
        session = context.session
        if not session:
            logger.error("No session provided in validation context")
            return

        # Extract user info
        # AdkApp typically populates context.user_content
        user_message = ""
        if context.user_content and context.user_content.parts:
            # Assuming first part is text
            part = context.user_content.parts[0]
            if hasattr(part, "text"):
                user_message = part.text or ""

        user_id = getattr(session, "user_id", "default")
        session_state = session.state

        from sre_agent.auth import (
            SESSION_STATE_SPAN_ID_KEY,
            SESSION_STATE_TRACE_FLAGS_KEY,
            SESSION_STATE_TRACE_ID_KEY,
            set_trace_id,
        )

        # PROPAGATION: Set Trace ID from Session State for log correlation
        remote_trace_id = session_state.get(SESSION_STATE_TRACE_ID_KEY)
        if remote_trace_id:
            set_trace_id(remote_trace_id)

        # PROPAGATION: Bridge OTel Context for SDK tracing
        from sre_agent.tools.common.telemetry import bridge_otel_context

        remote_span_id = session_state.get(SESSION_STATE_SPAN_ID_KEY)
        remote_flags = session_state.get(SESSION_STATE_TRACE_FLAGS_KEY, "01")

        otel_token = bridge_otel_context(
            trace_id=remote_trace_id, span_id=remote_span_id, trace_flags=remote_flags
        )

        # Extract Project ID from Session State
        # The proxy ensures this is set in session state before calling Agent Engine
        project_id = session_state.get(SESSION_STATE_PROJECT_ID_KEY)
        if project_id:
            from sre_agent.auth import set_current_project_id

            set_current_project_id(project_id)

        logger.info(
            f"ðŸš€ RunnerAdapter starting turn: user={user_id}, project={project_id}, session={session.id}"
        )

        try:
            # Reconstruct DomainContext from Session State
            # Investigation State should be in session state
            inv_state_dict = session.state.get("investigation_state", {})
            inv_state = (
                InvestigationState.from_dict(inv_state_dict) if inv_state_dict else None
            )

            domain_ctx = DomainContext(
                project_id=project_id,
                investigation_phase=inv_state.phase.value if inv_state else None,
            )

            async for event in self.runner.run_turn(
                session=session,
                user_message=user_message,
                user_id=user_id,
                project_id=project_id,
                domain_context=domain_ctx,
            ):
                yield event
        except Exception as e:
            logger.error(f"ðŸ”¥ RunnerAdapter failed: {e}", exc_info=True)
            # CRITICAL: Yield an error event so the client gets valid ADK protocol response
            # instead of a raw traceback/malformed JSON chunk.
            try:
                yield self.runner._create_error_event(str(e))
            except Exception:
                pass
            # Re-raise to allow AdkApp to handle/return error
            raise e
        finally:
            # Clean up OTel context
            if otel_token:
                try:
                    from opentelemetry import context as otel_ctx

                    otel_ctx.detach(otel_token)
                except Exception:
                    pass
